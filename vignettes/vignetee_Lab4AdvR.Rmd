---
title: "A linear regression package in R"
author: "Phillip HÃ¶lscher"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A linear regression package in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### This is a linear regression package in R

In this package are following functions inplemented **print()**, **plot()**, **resid()**, **pred()**, **coef()** and **summary()**. 
  
A demonstration will follow later in on this page.

First of all, this package empowers you to create linreg objects.
This is a references class (RC) object. 


- *For all demonstrations is the data set "iris" used.*

#### Create an object "mod_object"
```
mod_object <- linreg(Petal.Length~Species, data = iris)
```
We created an linreg object ob the object type RC. 
Used the as input data "iris" and used "Petal.Length" as dependent variable and as "Species" independent variable of the linear regression.

With the created object you can create followed calculations:
  
  - Regressions coefficients - *regressions_coef()*
  
  - fitted values - *fitted_values()*
  
  - residuals -*resi()*
  
  - degrees of freedom - *dof()*
  
  - residual variance - *resi_var()*
  
  - variance of the regression coefficients - *regressions_var()*
  
  - t-values for each coefficient - *t_value()*


### Example:  
```
mod_object$regressions_coef
```

### Methods
Like already maintained are some methods implemented.
### How to use the methods:

- **print()** print out the coefficients and coefficient names, similar as done by the lm class.

```
mod_object$print()
```

- **plot()** it will plot the two plots using ggplot2.
```
mod_object$plot()
```

  
- **resid()** it returns the vector of residuals e. 
```
mod_object$resid()
```

- **pred()**  it returns the predicted values yË†.
```
mod_object$pred()
```


- **coef()**  it returns the coefficients as a named vector.
```
mod_object$coef()
```

- **summary()** it returns a similar printout as printed for lm objects, but only  present the coefficients with their standard error, t-value and p-value as well as the estimate of ÏƒË† and the degrees of freedom in the model.
```
mod_object$summary()
```

### The Code 
```
linreg <- setRefClass("linreg",
                      fields = list(
                        X = "matrix",
                        y = "matrix",
                        regressions_coef = "matrix",
                        fitted_values = "matrix",
                        resi = "matrix",
                        n = "numeric",
                        p = "numeric",
                        dof = "numeric",
                        regressions_var = "matrix",
                        resi_var = "matrix",
                        t_value = "matrix",
                        m_formula ="formula",
                        m_data = "character"),

                      #--------------------------------
                      methods = list
                      (
                        #This function will calculate necessary parameters
                        initialize = function(formula, data)
                        {
                          #Generate X and y
                          X <<- model.matrix(formula, data)
                          y <<- as.matrix(data[all.vars(formula)[1]])

                          #Regressions coeficients
                          regressions_coef<<- as.matrix(solve(t(X)%*%X) %*% t(X)%*%y)

                          fitted_values <<- X%*%regressions_coef
                          #Residuals
                          resi <<- round(y - fitted_values, 3)
                          #Degrees of fredom
                          n <<- length(X[,1])
                          p <<- length(X[1,])
                          dof <<- n - p

                          #Variance of the regression coecients
                          resi_var <<- round(var(resi),3)
                          #t_value

                          t_value <<- regressions_coef/as.double(round(sqrt(resi_var),3))

                          #Metadata
                          m_formula <<- formula
                          m_data <<- deparse(substitute(data))
                        },

                        #The print method
                        print = function() {
                          cat(paste("Call: \n\n"))
                          cat(paste("linreg(formula = ",format(m_formula), ", data = ", m_data, ")\n\n", sep = ""))
                          cat(paste("Coefficients:\n"))

                          #table = setNames(data.frame(matrix(ncol = length(regressions_coef), nrow = 0)), rownames(regressions_coef))
                          #for (i in 1:length(regressions_coef)) {
                          #  table[1,i] = round(regressions_coef[i], 3)
                          #}
                          #my_print(table)

                          coef <- structure(as.vector(regressions_coef), names= format(rownames(regressions_coef)))
                          cat(paste("\  "))
                          #my_print(as.vector(regressions_coef))
                          my_print(coef)
                        },

                        #The plot method
                        plot = function()
                        {
                          library(ggplot2)

                          #Plot 1
                          residuals_vs_fitted <- ggplot(data.frame(resi, fitted_values), aes(x=fitted_values, y=resi)) +
                            geom_point() +
                            stat_smooth(method='lm', colour="red", se=FALSE, span = 1) +
                            xlab(paste("Fitted Values\n", "linreg(", format(m_formula), ")", ""))+
                            ylab("Residuals")

                          #stat_summary(aes(y = resi, x = fitted_values ,group=1), fun.y=median, colour="red", geom="line",group=1)

                          my_print(residuals_vs_fitted)

                          #Prepare for plot 2
                          std_vs_fitted <- as.data.frame(cbind(sqrt(abs(resi-mean(resi))), fitted_values))
                          names(std_vs_fitted) = c("Standardized_residuals", "fitted_values")
                          y_plot <- std_vs_fitted[,1]

                          #Plot 2
                          plot2 <- ggplot(std_vs_fitted, aes(x = fitted_values, y = y_plot))+
                            geom_point()+
                            stat_smooth(method='lm', colour="red", se=FALSE, span = 1) +
                            xlab(paste("Fitted Values\n", "linreg(", format(m_formula), ")", ""))+
                            ylab(expression(sqrt("|Standardized residuals|")))
                          #xlab(paste("Fitted Values\n", "lm(", format(l_formula), ")", ""))+
                          #ylab(expression(sqrt("|Standardized residuals|")))+
                          #stat_summary(aes(y = y_plot , x = fitted_values ,group=1),
                          #             fun.y= median,  colour="red", geom="line",group=1)

                          my_print(plot2)
                        },
                        resid = function(){
                          return(resi)
                        },
                        pred = function()
                        {
                          return(fitted_values)
                        },
                        coef = function(){
                          coef <- structure(as.vector(regressions_coef), names= row.names(regressions_coef))
                          return(coef)
                        },

                        #Summary method
                        summary = function()
                        {
                          cat(paste("Call: \n\n"))
                          cat(paste("linreg(formula = ",format(m_formula), ", data = ", m_data, ")\n\n", sep = ""))
                          cat(paste("Coefficients:\n\n"))

                          regressions_var <<- as.numeric(resi_var) * solve(t(X) %*% X)
                          table = data.frame(matrix(ncol = 5, nrow = 0))
                          for (i in 1:length(regressions_coef))
                          {
                            this_t_value = regressions_coef[i]/sqrt(regressions_var[i, i])
                            this_p_value = 2*pt(abs(this_t_value), dof, lower.tail = FALSE)
                            row = data.frame(round(regressions_coef[i], 2), round(sqrt(regressions_var[i, i]), 2), round(this_t_value, 2), formatC(this_p_value, format = "e", digits = 2), write_star(this_p_value))
                            rownames(row)[1] = rownames(regressions_coef)[i]
                            table = rbind(table, row)
                          }
                          output <- structure(table, names= c("Estimate", "Std Error", "t value", "Pr(>|t|)" , ""))
                          my_print(output)

                          cat(paste("\n"))
                          cat(paste("Residual standard error: ",round(sd(resi),3), " on ", dof, " degrees of freedom", sep = ""))
                        }

                      )
)

#Our own print function, because we can't call the default function inside RC object
my_print = function(x, stripoff = FALSE) {
  if (is.data.frame(x)) {
    print(x, row.names = stripoff)
  }
  else {
    print(x)
  }
}

write_star = function(p_value) {
  if (p_value > 0.1) return(" ")
  if (p_value > 0.05) return(".")
  if (p_value > 0.01) return("*")
  if (p_value > 0.001) return("**")
  return("***")
}

```

# This code is not the latest version - Update when fails are removed !
